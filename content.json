{"meta":{"title":"蜗牛","subtitle":"","description":"","author":"林蜗牛","url":"http://yoursite.com","root":"/"},"pages":[{"title":"photos","date":"2020-01-21T05:04:10.000Z","updated":"2020-01-21T05:04:10.672Z","comments":true,"path":"photos/index.html","permalink":"http://yoursite.com/photos/index.html","excerpt":"","text":""},{"title":"hexo","date":"2020-02-07T05:30:49.000Z","updated":"2020-02-07T05:30:50.000Z","comments":true,"path":"hexo/index.html","permalink":"http://yoursite.com/hexo/index.html","excerpt":"","text":""},{"title":"sort","date":"2020-09-09T05:30:10.000Z","updated":"2020-09-09T11:31:58.939Z","comments":true,"path":"sort/堆排序.html","permalink":"http://yoursite.com/sort/%E5%A0%86%E6%8E%92%E5%BA%8F.html","excerpt":"堆排序1、概念​ 堆排序(Heapsort)是指利用堆这种数据结构所设计的一种算法。堆的结构近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父结点。","text":"堆排序1、概念​ 堆排序(Heapsort)是指利用堆这种数据结构所设计的一种算法。堆的结构近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父结点。 2、堆​ 堆是一颗顺序存储的完全二叉树。 ​ 其中子节点的键值或索引总是大于它的父结点，这样的堆称为小根堆。 ​ 其中子节点的键值或索引总是小于它的父结点，这样的堆称为小根堆。 假设用数组存储堆，其父节点的索引下标为i，则有： 左孩子节点下标：left = 2 * i + 1​ 右孩子节点下标：left = 2 * i + 2 ​ 它的父节点下标：parent = (i - 1) / 2 3、算法思想 首先，按堆的定义将数组 R[0..n]调整为堆（这个过程称为创建初始堆），交换 R[0]和 R[n]； 然后，将 R[0..n-1]调整为堆，交换 R[0]和 R[n-1]； 如此反复，直到交换了 R[0]和 R[1]为止。 4、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142private static void heapAdjust(int[] arr, int parent, int length) &#123; //temp 保存当前父节点 int temp = arr[parent]; //先获得左孩子 int child = 2 * parent + 1; while (child &lt; length)&#123; //如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选右孩子结点 if (child + 1 &lt; length &amp;&amp; arr[child + 1] &gt; arr[child])&#123; child++; &#125; //如果父结点的值已经大于孩子结点的值，则直接结束 if (temp &gt;= arr[child])&#123; break; &#125; //把孩子结点的值赋给父结点 arr[parent] = arr[child]; //选取孩子结点的左孩子结点，继续向下筛选 parent = child; child = 2 * child + 1; &#125; arr[parent] = temp; &#125; private static int[] heapSrot(int[] arr) &#123; //循环建立初始堆 for (int i = arr.length /2 ; i &gt;= 0; i--) &#123; heapAdjust(arr,i,arr.length); &#125; //进行n-1次循环，完成排序 for (int i = arr.length - 1; i &gt; 0 ; i--) &#123; int temp = arr[i]; arr[i] = arr[0]; arr[0] = temp; // 筛选 R[0] 结点，得到i-1个结点的堆 heapAdjust(arr,0,i); &#125; return arr; &#125;"}],"posts":[{"title":"hello","slug":"hello","date":"2020-02-07T05:27:51.000Z","updated":"2020-02-07T05:29:05.338Z","comments":true,"path":"2020/02/07/hello/","link":"","permalink":"http://yoursite.com/2020/02/07/hello/","excerpt":"","text":"","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"java算法入门笔记（二）简单排序","slug":"java算法入门笔记（二）简单排序","date":"2020-02-05T12:41:40.925Z","updated":"2020-02-07T05:04:10.940Z","comments":true,"path":"2020/02/05/java算法入门笔记（二）简单排序/","link":"","permalink":"http://yoursite.com/2020/02/05/java%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/","excerpt":"简单排序：冒泡排序、选择排序、插入排序，不足之处评论指出，不胜感谢！","text":"简单排序：冒泡排序、选择排序、插入排序，不足之处评论指出，不胜感谢！ 一、冒泡排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class BubbleSort &#123; /** * 冒泡排序 * @param arr 排序数组 * @param flat 0为降序，非0为升序 */ public static void BubbleSort01(long[] arr,int flat)&#123; long temp = 0; for (int i = 0; i &lt; arr.length -1; i++)&#123; for (int j = arr.length-1; j &gt; i; j--)&#123; if (flat != 0) &#123; if (arr[j] &lt; arr[j - 1]) &#123; temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; &#125; &#125;else&#123; if (arr[j] &gt; arr[j - 1]) &#123; temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; long[] arr =new long[5]; for (int i = 0; i &lt; arr.length ;i++)&#123; arr[i]= (long) (Math.random()*100); &#125; System.out.print(\"原始数组为：\"+\"[\"); for (long num : arr)&#123; System.out.print(num + \" \" ); &#125; System.out.println(\"]\"); BubbleSort.BubbleSort01(arr,1); System.out.print(\"冒泡排序（升序）后数组为：\"+\"[\"); for (long num : arr)&#123; System.out.print(num + \" \" ); &#125; System.out.println(\"]\"); BubbleSort.BubbleSort01(arr,0); System.out.print(\"冒泡排序（降序）后数组为：\"+\"[\"); for (long num : arr)&#123; System.out.print(num + \" \" ); &#125; System.out.println(\"]\"); &#125;&#125; 二、选择排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class SelectionSort &#123; /** * 选择排序 * @param arr 需要排序的数组 * @param flat 0为降序，非0为升序 */ public static void SelectionSort(long[] arr,int flat)&#123; int index = 0; long temp = 0; for(int i = 0; i &lt;arr.length; i++)&#123; for (int j = i; j &lt; arr.length;j++)&#123; if (flat != 0) &#123; if (arr[index] &gt; arr[j]) &#123; index = j; &#125; &#125;else&#123; if (arr[index] &lt; arr[j]) &#123; index = j; &#125; &#125; &#125; temp = arr[i]; arr[i] = arr[index]; arr[index] = temp; &#125; &#125; public static void main(String[] args) &#123; long[] arr =new long[5]; for (int i = 0; i &lt; arr.length ;i++)&#123; arr[i]= (long) (Math.random()*100); &#125; System.out.print(\"原始数组为：\"+\"[\"); for (long num : arr)&#123; System.out.print(num + \" \" ); &#125; System.out.println(\"]\"); SelectionSort.SelectionSort(arr,1); System.out.print(\"选择排序（升序）后数组为：\"+\"[\"); for (long num : arr)&#123; System.out.print(num + \" \" ); &#125; System.out.println(\"]\"); SelectionSort.SelectionSort(arr,0); System.out.print(\"选择排序（降序）后数组为：\"+\"[\"); for (long num : arr)&#123; System.out.print(num + \" \" ); &#125; System.out.println(\"]\"); &#125;&#125; 三、插入排序123456789101112131415161718192021222324252627282930313233343536373839404142public class InsertSort &#123; /** * 插入排序 * @param arr 需要排序的数组 */ public static void InsertSort(long[] arr)&#123; long temp = 0; for(int i = 1; i &lt; arr.length;i++)&#123; temp = arr[i]; int j = i; while (j &gt; 0 &amp;&amp; arr[j] &gt;= temp)&#123; arr[j] = arr[j -1]; j--; &#125; arr[j] = temp; &#125; &#125; public static void main(String[] args) &#123; long[] arr =new long[5]; for (int i = 0; i &lt; arr.length ;i++)&#123; arr[i]= (long) (Math.random()*100); &#125; System.out.print(\"原始数组为：\"+\"[\"); for (long num : arr)&#123; System.out.print(num + \" \" ); &#125; System.out.println(\"]\"); InsertSort.InsertSort(arr); System.out.print(\"直接插入排序（升序）后数组为：\"+\"[\"); for (long num : arr)&#123; System.out.print(num + \" \" ); &#125; System.out.println(\"]\"); &#125;&#125;","categories":[],"tags":[]},{"title":"日常发呆（一）","slug":"日常发呆（一）","date":"2020-02-05T11:12:05.580Z","updated":"2020-02-07T04:57:12.850Z","comments":true,"path":"2020/02/05/日常发呆（一）/","link":"","permalink":"http://yoursite.com/2020/02/05/%E6%97%A5%E5%B8%B8%E5%8F%91%E5%91%86%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"编程题： ​ 你就是一个画家！你现在想绘制一幅画，但是你现在没有足够颜色的颜料。为了让问题可简单，我们用正整数表示不同颜色的颜料。你知道这幅画需要n种颜色的颜料，你现在可以去商店购买一些颜料哦，但是商店不能保证能供应所有颜色的颜料，所以你需要自己混合一些颜料 。混合两种不一样的颜色A和颜色B可以产生（A XOR B）这种颜色的颜料（新产生的颜料也可以用作继续混合产生新的颜色，XOR表示异或操作）。本着请见节约的精神，你想购买更少的颜料就满足要求，所以兼职程序员的你需要编程来计算出最少需要购买几种颜色的颜料？ ​ 输入描述：第一行为绘制这幅画需要的颜色种数n（1≤ n≤50）。第二行为n个数xi（1≤ xi≤1,000,000,000），表示需要的各种颜料。 ​ 输出描述：输出最少需要在商店购买的颜料颜色种数，注意可能购买的颜色不一定会使用在画中，只是为了产生新的颜色。 ​ 输入例子1： ​ 3 ​ 1 7 3 ​ 输出例子1： ​ 3","text":"编程题： ​ 你就是一个画家！你现在想绘制一幅画，但是你现在没有足够颜色的颜料。为了让问题可简单，我们用正整数表示不同颜色的颜料。你知道这幅画需要n种颜色的颜料，你现在可以去商店购买一些颜料哦，但是商店不能保证能供应所有颜色的颜料，所以你需要自己混合一些颜料 。混合两种不一样的颜色A和颜色B可以产生（A XOR B）这种颜色的颜料（新产生的颜料也可以用作继续混合产生新的颜色，XOR表示异或操作）。本着请见节约的精神，你想购买更少的颜料就满足要求，所以兼职程序员的你需要编程来计算出最少需要购买几种颜色的颜料？ ​ 输入描述：第一行为绘制这幅画需要的颜色种数n（1≤ n≤50）。第二行为n个数xi（1≤ xi≤1,000,000,000），表示需要的各种颜料。 ​ 输出描述：输出最少需要在商店购买的颜料颜色种数，注意可能购买的颜色不一定会使用在画中，只是为了产生新的颜色。 ​ 输入例子1： ​ 3 ​ 1 7 3 ​ 输出例子1： ​ 3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Scanner;public class MixedPigment &#123; int count(int[] arr, int n)&#123; int num=n; int maxdataindex = 0; for (int i = 0;i &lt; n; i++)&#123; if (arr[i] &gt; arr[maxdataindex]) &#123; maxdataindex = i; &#125; &#125; for (int i = 0; i &lt; n; ++i )&#123; if (i != maxdataindex)&#123; int temp = arr[i]; arr[i] = arr[maxdataindex]; arr[maxdataindex] = temp; &#125; if (arr[i] == 0)&#123; num = i; break; &#125; maxdataindex = i + 1; for (int j = i + 1; j &lt; n; ++j)&#123; if (arr[j] != 0) &#123; int temp = arr[i] ^ arr[j]; if (temp &lt; arr[i]) arr[j] = temp; if (arr[maxdataindex] &lt; arr[j]) maxdataindex = j; &#125; &#125; &#125; return num; &#125; public static void main(String[] args) &#123; int n; Scanner sc = new Scanner(System.in); while (true)&#123; n = sc.nextInt(); int[] arr = new int[n]; for (int i= 0; i &lt; n; i++)&#123; arr[i] = sc.nextInt(); &#125; MixedPigment mixedPigment = new MixedPigment(); System.out.println(mixedPigment.count(arr,n)); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"SpringBoot学习日记（一）","slug":"SpringBoot学习日记（一）","date":"2020-02-05T11:12:05.578Z","updated":"2020-02-07T05:01:08.560Z","comments":true,"path":"2020/02/05/SpringBoot学习日记（一）/","link":"","permalink":"http://yoursite.com/2020/02/05/SpringBoot%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"一、Springboot快速入门日常小笔记，本文只是简单介绍如何大家SpringBoot的项目，哈哈哈！ 入门案例：Hellowrold！","text":"一、Springboot快速入门日常小笔记，本文只是简单介绍如何大家SpringBoot的项目，哈哈哈！ 入门案例：Hellowrold！ 1、使用idea工具创建maven工程，该工程为普通Java工程即可 2、添加在pom.xml中添加springboot的起步依赖 SpringBoot要求，项目要继承Springbooot的起步依赖spring-boot-starter-parent 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt; SpringBoot要集成SpringMVC进行Controller的开发，所以项目要导入web的启动依赖 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写SpringBoot引导类 要通过SpringBoot提供的引导类起步SpringBoot才可以进行访问 123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125;","categories":[],"tags":[]},{"title":"java算法入门笔记（一）数组","slug":"java算法入门笔记（一）数组","date":"2020-02-04T14:02:58.790Z","updated":"2020-02-07T05:02:37.443Z","comments":true,"path":"2020/02/04/java算法入门笔记（一）数组/","link":"","permalink":"http://yoursite.com/2020/02/04/java%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E7%BB%84/","excerpt":"简单java’数组入门，不足之处评论指出，不胜感谢！","text":"简单java’数组入门，不足之处评论指出，不胜感谢！ 1.声明数组和创建数组（1）声明数组1234int[] arr //声明一个数组变量[] //表示该变量是一个数组int //表示数组类型arr //表示数组变量名称 例1.1123456public class Array&#123; public static void main(String[] args )&#123; //声明一个数组 int[] arr; &#125; &#125; （2）创建数组注意：创建数组时，要指明数组的长度。 12int[] arr1 = new int[50]; //数组长度为50int[] arr2 = new int[]&#123;2,2,3] //数组长度为数组元素的个数 例1.2123456789101112public class Array&#123; public static void main(String[] args)&#123; //第一种写法 int[] arr1; //声明数组 arr1 = new int[10]; //初始化数组，定义数组的大小 //int[] arr = new int[10]; int[] arr2; arr2 = new int[]&#123;2,3,4&#125;; //int[] arr2 = new int[]&#123;2,3,4&#125;; &#125;&#125; 2.访问数组和数组长度（1）访问数组访问数组可以通过数组下标访问数组存储的值 注意:数组下标基0，即数组下标从0开始，下标为0表示数组的第一个数，最大的下标 = 数组长度 - 1 例2.1123456789101112131415public class Array&#123; public static void main(String[] args)&#123; int[] arr; arr = new int[5]; arr[0] = 1; //下标0，表示数组的第一个数 arr[1] = 2; arr[2] = 3; arr[3] = 4; arr[4] = 5; //打印数组的第一个元素的值 System.out.println(arr[0]); &#125;&#125; （2）数组长度可以通过.length属性来访问一个数组的长度 例2.212345678910111213public class Array&#123; public void static main(String[] args)&#123; int[] arr = new int[]&#123;2,3,4,5,6,7&#125;; //打印数组长度 System.out.println(arr.length); //打印数组 System.out.print(\"[\"); for(int i = 0; i &lt; arr.length; i++)&#123; System.out.print(arr[i] + \" \"); &#125; System.out.print(\"]\"); &#125;&#125; 3.自定义封装数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class MyArray &#123; private long[] arr; //表示有效数组长度 private int elements; public MyArray() &#123; arr = new long[50]; &#125; /** * 插入数据 */ public void insert(long value) &#123; arr[elements] = value; elements++; &#125; /** * 有序插入 * @param value */ public void orderinsert(long value) &#123; int i; //找到要插入的位置下标 for(i = 0; i &lt; elements; i++)&#123; if (arr[i]&gt; value)&#123; break; &#125; &#125; //数组后移 for(int j = elements; j &gt; i; j--)&#123; arr[j] = arr[j-1]; &#125; arr[i] = value; elements++; &#125; /** * 显示数据 */ public void display() &#123; System.out.print(\"[\"); for (int i = 0; i &lt; elements; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(\"]\"); &#125; /** * 查找数据,根据值查找索引 */ public int search(long value) &#123; int i; for (i = 0; i &lt; elements; i++) &#123; if (value == arr[i]) &#123; break; &#125; &#125; if (i == elements) &#123; return -1; &#125; else &#123; return i; &#125; &#125; /** * 查找数据，根据索引查找 */ public long get(int index) &#123; if (index &gt;= elements || index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; else &#123; return arr[index]; &#125; &#125; /** * 二分法查找数据 */ public int binarySearch(long value) &#123; int middle = 0; int low = 0; int pow = elements; while(true) &#123; middle = (pow + low) / 2; if(arr[middle] == value) &#123; return middle; &#125; else if(low &gt; pow) &#123; return -1; &#125; else &#123; if(arr[middle] &gt; value) &#123; pow = middle - 1; &#125; else &#123; low = middle + 1; &#125; &#125; &#125; &#125; /** * 删除数据 */ public void delete(int index) &#123; if (index &gt;= elements || index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; else &#123; for (int i = index; i &lt; elements; i++) &#123; arr[index] = arr[index + 1]; &#125; elements--; &#125; &#125; /** * 更新数据 */ public void change(int index, long newvalue)&#123; if (index &gt;= elements || index &lt; 0)&#123; throw new ArrayIndexOutOfBoundsException(); &#125;else&#123; arr[index] = newvalue ; &#125; &#125; &#125; 4.练习例4.1查找数组里的最小值1234567891011121314151617181920212223public class FindMIn &#123; public static void main(String[] args) &#123; int[] arr = new int[5]; for (int i = 0; i &lt; arr.length; i++)&#123; arr[i] = (int) (Math.random()*100); &#125; System.out.println(\"数组中各个随机数是：\"); System.out.print(\"[\"); for (int j = 0; j &lt; arr.length; j++)&#123; System.out.print(arr[j] + \" \"); &#125; System.out.println(\"]\"); int min = arr[0]; for(int k = 0; k &lt; arr.length; k++)&#123; if(arr[k] &lt; min)&#123; min = arr[k]; &#125; &#125; System.out.println(\"最小值为：\"+ min); &#125;&#125;","categories":[],"tags":[]}]}